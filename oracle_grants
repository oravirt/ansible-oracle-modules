#!/usr/bin/python
# -*- coding: utf-8 -*-

DOCUMENTATION = '''
---
module: oracle_grants
short_description: Manage users/schemas in an Oracle database
description:
    - Manage grants/privileges in an Oracle database
    - Handles role/sys privileges at the moment.
    - It is possible to add object privileges as well, but they are not considered when removing privs at the moment.
version_added: "1.9.1"
options:
    hostname:
        description:
            - The Oracle database host
        required: false
        default: localhost
    port:
        description:
            - The listener port number on the host
        required: false
        default: 1521
    service_name:
        description:
            - The database service name to connect to
        required: true
    user:
        description:
            - The Oracle user name to connect to the database
        required: true
    password:
        description:
            - The Oracle user password for 'user'
        required: true
    mode:
        description:
            - The mode with which to connect to the database
        required: true
        default: normal
        choices: ['normal','sysdba']
    schema:
        description:
            - The schema that should get grants added/removed
        required: false
        default: null
    grants:
        description:
            - The privileges granted to the new schema. Can be a string or a list
        required: false
        default: null
    object_privs:
        description:
            - The privileges granted to specific objects
            - format: 'priv1,priv2,priv3:owner.object_name'
              e.g:
              - select,update,insert,delete:sys.dba_tablespaces
              - select:sys.v_$session
        required: false
        default: null
    grants_mode:
        description:
            - Should the list of grants be enforced, or just appended to.
              enforce: Whatever is in the list of grants will be enforced, i.e grants/privileges will be removed if they are not in the list
              append: Grants/privileges are just appended, nothing is removed
        default: enforce
        choices: ['enforce','append']
    state:
        description:
            - The intended state of the priv (present=added to the user, absent=removed from the user). REMOVEALL will remove ALL role/sys privileges
        default: present
        choices: ['present','absent','REMOVEALL']
notes:
    - cx_Oracle needs to be installed
requirements: [ "cx_Oracle" ]
author: Mikael SandstrÃ¶m, oravirt@gmail.com, @oravirt
'''

EXAMPLES = '''
# Add grants to the user
oracle_grants: hostname=remote-db-server service_name=orcl user=system password=manager schema=myschema state=present grants='create session','create any table',connect,resource

# Revoke the 'create any table' grant
oracle_grants: hostname=localhost service_name=orcl user=system password=manager schema=myschema state=absent grants='create any table'

# Remove all grants from a user
oracle_grants: hostname=localhost service_name=orcl user=system password=manager schema=myschema state=REMOVEALL grants=


'''

try:
    import cx_Oracle
except ImportError:
    cx_oracle_exists = False
else:
    cx_oracle_exists = True


def clean_string(item):
    item = item.replace("'","").replace(", ",",").lstrip(" ").rstrip(",").replace("[","").replace("]","")
    return item


def clean_list(item):
    item = [p.replace("'","").replace(", ",",").lstrip(" ").rstrip(",").replace("[","").replace("]","") for p in item]
    return item


# Check if the user/schema exists
def check_user_exists(module, msg, cursor, schema):
    if not schema:
        module.fail_json(msg='Error: Missing schema name (User)', changed=False)
        return False

    schema = clean_string(schema)
    sql = 'select count(*) from dba_users where username = upper(\'%s\')' % schema
    try:
            cursor.execute(sql)
            result = cursor.fetchone()[0]
    except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = error.message+ ' sql: ' + sql
            module.fail_json(msg=msg, changed=False)

    if result > 0:
        return True
    msg = "User doesn't exist"
    module.fail_json(msg=msg, changed=False)


# Check if the user/role exists
def check_role_exists(module, msg, cursor, role):
    if not role:
        module.fail_json(msg='Error: Missing role name', changed=False)
        return False

    role = clean_string(role)
    sql = 'select count(*) from dba_roles where role = upper(\'%s\')' % role
    try:
            cursor.execute(sql)
            result = cursor.fetchone()[0]
    except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = error.message+ ' sql: ' + sql
            module.fail_json(msg=msg, changed=False)

    if result > 0:
        return True
    msg = "Role doesn't exist"
    module.fail_json(msg=msg, changed=False)


def get_dir_priv_sqls(module, msg, cursor, schema, directory_privs, mode):
    DirPrivilege = namedtuple('DirPrivilege', ['privilege', 'owner', 'directory'])

    total_sql_dir = []
    # Directory Privs
    wanted_dirprivs_set = set()
    for dp in directory_privs:
        p = dp.split(':')[0].lower()
        d = dp.split(':')[1].lower()
        if '.' in d: # all directories in oracle are owner by SYS by design
            o = d.split('.')[0]
            d = d.split('.')[1]
        else:
            o = 'sys'

        if p == 'all':
            wanted_dirprivs_set.add(DirPrivilege('read', o, d))
            wanted_dirprivs_set.add(DirPrivilege('write', o, d))
            wanted_dirprivs_set.add(DirPrivilege('execute', o, d))
        else:
            wanted_dirprivs_set.add(DirPrivilege(p, o, d))

    curr_dir_privs_set = set()
    currdsql_all="""
    select p.privilege, p.owner, p.table_name
    from dba_tab_privs p, dba_objects o
    where p.grantee = upper(\'%s\')
    and p.table_name = o.object_name
    and p.owner = o.owner
    and o.object_type = 'DIRECTORY'
    order by 2,3,1
    """ % (schema)
    result = execute_sql_get(module, msg, cursor, currdsql_all)
    for r in result:
        p = r[0].lower()
        o = r[1].lower()
        d = r[2].lower()
        curr_dir_privs_set.add(DirPrivilege(p, o, d))

    unnecessary_dir_privs_set = curr_dir_privs_set.difference()
    missing_dir_privs_set  = wanted_dirprivs_set.difference(curr_dir_privs_set)

    #module.warn("Missing: " + str(missing_dir_privs_set))
    #module.warn("Unnecessary: " + str(unnecessary_dirprivs_list))

    if mode == 'REMOVEALL':
        for p in curr_dir_privs_set:
            rdsql = "revoke %s on directory %s.%s from %s" % (p.privilege, p.owner, p.directory, schema)
            total_sql_dir.append(rdsql)
        return total_sql_dir

    if mode.lower() == 'enforce':
        for p in unnecessary_dir_privs_set:
            rdsql = "revoke %s on directory %s.%s from %s" % (p.privilege, p.owner, p.directory, schema)
            total_sql_dir.append(rdsql)

    for p in missing_dir_privs_set:
        adsql = "grant %s on directory %s.%s to %s" % (p.privilege, p.owner, p.directory, schema)
        total_sql_dir.append(adsql)

    return total_sql_dir


def get_obj_privs (module, msg, cursor, schema, object_privs, mode):
    ObjPrivilege = namedtuple('ObjPrivilege', ['privilege', 'owner', 'object'])

    default_user = execute_sql_get(module, msg, cursor, 'select user from dual')[0][0].lower()

    total_sql_obj = []
    # OBJECT PRIVS
    wanted_obj_privs_set = set()
    for dp in object_privs:
        p = dp.split(':')[0].lower()
        obj = dp.split(':')[1].lower()
        if '.' in obj: # all directories in oracle are owner by SYS by design
            o   = obj.split('.')[0]
            obj = obj.split('.')[1]
        else:
            o = default_user

        if p == 'all':
            wanted_obj_privs_set.add(ObjPrivilege('alter', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('delete', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('index', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('insert', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('select', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('update', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('references', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('read', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('on commit refresh', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('query rewrite', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('debug', o, obj))
            wanted_obj_privs_set.add(ObjPrivilege('flashback', o, obj))
        else:
            wanted_obj_privs_set.add(ObjPrivilege(p, o, obj))

    curr_obj_privs_set = set()
    currsql_all="""
    select p.privilege, p.owner, p.table_name
    from dba_tab_privs p, dba_objects o
    where p.grantee = upper(\'%s\')
    and p.table_name = o.object_name
    and p.owner = o.owner
    and o.object_type not in ('DIRECTORY','TABLE PARTITION','TABLE SUBPARTITION')
    order by 2,3,1
    """ % (schema)
    result = execute_sql_get(module, msg, cursor, currsql_all)
    for r in result:
        p = r[0].lower()
        o = r[1].lower()
        d = r[2].lower()
        curr_obj_privs_set.add(ObjPrivilege(p, o, d))

    unnecessary_obj_privs_set = curr_obj_privs_set.difference(wanted_obj_privs_set)
    missing_obj_privs_set  = wanted_obj_privs_set.difference(curr_obj_privs_set)

    #module.warn("Missing: " + str(missing_dir_privs_set))
    #module.warn("Unnecessary: " + str(unnecessary_dir_privs_set))

    if mode == 'REMOVEALL':
        for p in curr_obj_privs_set:
            rdsql = "revoke %s on directory %s.%s from %s" % (p.privilege, p.owner, p.object, schema)
            total_sql_obj.append(rdsql)
        return total_sql_obj

    if mode.lower() == 'enforce':
        for p in unnecessary_obj_privs_set:
            rdsql = "revoke %s on %s.%s from %s" % (p.privilege, p.owner, p.object, schema)
            total_sql_obj.append(rdsql)

    for p in missing_obj_privs_set:
        adsql = "grant %s on %s.%s to %s" % (p.privilege, p.owner, p.object, schema)
        total_sql_obj.append(adsql)

    return total_sql_obj


# Add grants to the schema/role
def ensure_grants(module, msg, cursor, schema, wanted_grants_list, object_privs, directory_privs, grants_mode, container):
    if not schema: # or not(wanted_grants_list):
        module.fail_json(msg='Error: Missing schema/role name or grants', changed=False)
        return False

    # If no privs are added, we set the 'wanted' lists to be empty.
    if wanted_grants_list is None or wanted_grants_list == ['']:
        wanted_grants_list = []
    if object_privs is None or object_privs == ['']:
        object_privs = []
    if directory_privs is None or directory_privs == ['']:
        directory_privs = []

    # This list will hold all grants the user currently has
    total_sql=[]
    total_current=[]

    dir_privs = get_dir_priv_sqls(module, msg, cursor, schema, directory_privs, grants_mode)
    total_sql.extend(dir_privs)

    obj_privs = get_obj_privs(module, msg, cursor, schema, object_privs, grants_mode)
    total_sql.extend(obj_privs)

    #module.exit_json(msg=total_sql)
    exceptions_list=['DBA']
    exceptions_priv=['UNLIMITED TABLESPACE']

    # Strip the list of unnecessary quotes etc
    wanted_grants_list = clean_list(wanted_grants_list)
    wanted_grants_list = [x.lower() for x in wanted_grants_list]
    wanted_grants_list_upper = [x.upper() for x in wanted_grants_list]
    schema = clean_string(schema)

    # Get the current role grants for the schema. If any are present, add them to the total
    curr_role_grants=get_current_role_grants(module, msg, cursor, schema)
    if any(curr_role_grants):
        total_current.extend(curr_role_grants)

    # Get the current sys privs for the schema. If any are present, add them to the total
    curr_sys_grants=get_current_sys_grants(module, msg, cursor, schema)
    if any(curr_sys_grants):
        total_current.extend(curr_sys_grants)

    # Get the difference between current grants and wanted grants
    grants_to_add=set(wanted_grants_list).difference(total_current)
    grants_to_remove=set(total_current).difference(wanted_grants_list)

    # Special case: If DBA is granted to a user, unlimited tablespace is also implicitly
    # granted -> on the next run, unlimited tablespace is removed from the user
    # since it is not part of the wanted grants.
    # The following removes 'unlimited tablespace' privilege from the grants_to_remove list, if DBA is also granted
    if any(x in exceptions_list for x in wanted_grants_list_upper):
        grants_to_remove = [x for x in grants_to_remove if x.upper() not in exceptions_priv]

    # Convert the list of grants to a string
    if any(grants_to_remove) and grants_mode.lower() == 'enforce':
        grants_to_remove = ','.join(grants_to_remove)
        grants_to_remove = clean_string(grants_to_remove)
        remove_sql = 'revoke %s from %s' % (grants_to_remove, schema)
        total_sql.append(remove_sql)

    if any(grants_to_add):
        grants_to_add = ','.join(grants_to_add)
        grants_to_add = clean_string(grants_to_add)
        add_sql = 'grant %s to %s' % (grants_to_add, schema)
        if container:
            add_sql += ' container=%s' % (container)
        total_sql.append(add_sql)

    # module.exit_json(msg=total_sql)
    if total_sql:
        ensure_grants_state_sql(module, msg, cursor,total_sql)
        module.exit_json(msg=total_sql, changed=True)
    else:
        msg = 'Nothing to do'
        module.exit_json(msg=msg, changed=False)


def ensure_grants_state_sql(module,msg,cursor,total_sql):
    for a in total_sql:
        execute_sql(module, msg, cursor, a)
    return True


def execute_sql(module, msg, cursor, sql):
    try:
        cursor.execute(sql)
    except cx_Oracle.DatabaseError as exc:
        error, = exc.args
        msg = 'Something went wrong while executing sql - %s sql: %s' % (error.message, sql)
        module.fail_json(msg=msg, changed=False)
        return False
    return True


# Remove grants to the schema
def remove_grants(module, msg, cursor, schema, system_grants, object_privs, directory_privs, state):
    total_sql = []

    if state == 'REMOVEALL':
        dir_privs = get_dir_priv_sqls(module, msg, cursor, schema, directory_privs = [], mode='enforce')
        total_sql.extend(dir_privs)
    else: # state == 'absent'
        pass

    if state == 'REMOVEALL':
        obj_privs = get_obj_privs(module, msg, cursor, schema, object_privs = [], mode='enforce')
        total_sql.extend(obj_privs)
    else: # state == 'absent'
        pass

    # Strip the list of unnecessary quotes etc
    remove_grants_list = clean_list(system_grants)
    schema = clean_string(schema)

    # This list will hold all grants/privs the user currently has
    total_current=set()

    # Get the current role grants for the schema.
    # If any are present, add them to the total
    curr_role_grants=get_current_role_grants(module, msg, cursor, schema)
    if any(curr_role_grants):
        total_current.update(curr_role_grants)

    # Get the current sys privs for the schema
    # If any are present, add them to the total
    curr_sys_grants=get_current_sys_grants(module, msg, cursor, schema)
    if any(curr_sys_grants):
        total_current.update(curr_sys_grants)

    # Get the difference between current grants and wanted grants
    grants_to_remove=set(remove_grants_list).intersection(total_current)

    # If state=REMOVEALL is used, all grants/privs will be removed
    if state == 'REMOVEALL'  and any(total_current):
        remove_all = ','.join(total_current)
        sql += 'revoke %s from %s' % (remove_all, schema)
        msg = 'All privileges/grants (%s) are removed from schema/role %s' % (remove_all, schema)

        try:
            cursor.execute(sql)
        except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = 'Something went wrong while removing all grants from the schema/role - %s sql: %s' % (error.message, sql)
            return False

    # if there are differences, they will be removed.
    elif not any(grants_to_remove):
        module.exit_json(msg="The schema/role (%s) doesn't have the grant(s) you want to remove" % schema, changed=False)

    else:
        # Convert the list of grants to a string & clean it
        grants_to_remove = ','.join(grants_to_remove)
        grants_to_remove = clean_string(grants_to_remove)
        sql += 'revoke %s from %s' % (grants_to_remove, schema)
        msg = 'The grant(s) (%s) successfully removed from the schema/role %s' % (grants_to_remove, schema)

        try:
            cursor.execute(sql)
        except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = 'Blergh, something went wrong while removing grants from the schema/role - %s sql: %s' % (error.message, sql)
            return False

    return True


# Get the current role/sys grants
def get_current_role_grants(module, msg, cursor, schema):
    curr_role_grants=set()
    sql = 'select granted_role from dba_role_privs where grantee = upper(\'%s\') '% schema
    try:
            cursor.execute(sql)
            result = cursor.fetchall()
    except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = error.message+ 'sql: ' + sql
            module.fail_json(msg=msg, changed=False)

    for item in result:
        curr_role_grants.add(item[0].lower())

    return curr_role_grants


# Get the current sys grants
def get_current_sys_grants(module, msg, cursor, schema):
    curr_sys_grants=set()
    sql = 'select privilege from dba_sys_privs where grantee = upper(\'%s\') '% schema
    try:
            cursor.execute(sql)
            result = cursor.fetchall()
    except cx_Oracle.DatabaseError as exc:
            error, = exc.args
            msg = error.message+ 'sql: ' + sql
            module.fail_json(msg=msg, changed=False)

    for item in result:
        curr_sys_grants.add(item[0].lower())
    return curr_sys_grants


def execute_sql_get(module, msg, cursor, sql):
    try:
        cursor.execute(sql)
        result = (cursor.fetchall())
    except cx_Oracle.DatabaseError as exc:
        error, = exc.args
        msg = 'Something went wrong while executing sql_get - %s sql: %s' % (error.message, sql)
        module.fail_json(msg=msg, changed=False)
        return False
    return result


def main():
    msg = ['']
    module = AnsibleModule(
        argument_spec = dict(
            oracle_home   = dict(required=False, aliases=['oh']),
            hostname      = dict(default='localhost'),
            port          = dict(default=1521, type="int"),
            service_name  = dict(required=False),
            user          = dict(required=False),
            password      = dict(required=False, no_log=True),
            mode          = dict(default='normal', choices=["normal","sysdba"]),
            schema        = dict(default=None),
            role          = dict(default=None),
            grants        = dict(default=None, type="list"),
            object_privs  = dict(default=None, type="list",aliases=['objprivs']),
            directory_privs   = dict(default=None, type="list",aliases=['dirprivs']),
            grants_mode   = dict(default="enforce", choices=["append", "enforce"],aliases=['privs_mode']),
            container     = dict(default=None),
            state         = dict(default="present", choices=["present", "absent", "REMOVEALL"])

        ),
        mutually_exclusive=[['schema', 'role']]
    )

    oracle_home = module.params["oracle_home"]
    hostname = module.params["hostname"]
    port = module.params["port"]
    service_name = module.params["service_name"]
    user = module.params["user"]
    password = module.params["password"]
    mode = module.params["mode"]
    schema = module.params["schema"]
    role = module.params["role"]
    system_grants = module.params["grants"]
    object_privs = module.params["object_privs"]
    directory_privs = module.params["directory_privs"]
    grants_mode = module.params["grants_mode"]
    container = module.params["container"]
    state = module.params["state"]

    if not cx_oracle_exists:
        module.fail_json(msg="The cx_Oracle module is required. 'pip install cx_Oracle' should do the trick. If cx_Oracle is installed, make sure ORACLE_HOME is set")

    conn = oracle_connect(module)
    cursor = conn.cursor()

    if state == 'present' and schema:
        check_user_exists(module, msg, cursor, schema)
        ensure_grants(module, msg, cursor, schema, system_grants, object_privs, directory_privs, grants_mode, container)

    elif state == 'present' and role:
        check_role_exists(module, msg, cursor, role)
        ensure_grants(module, msg, cursor, role, system_grants, object_privs, directory_privs, grants_mode, container)

    elif (state == 'absent' or state == 'REMOVEALL') and schema:
        check_user_exists(module, msg, cursor, schema)
        if state == 'REMOVEALL':
            remove_grants(module, msg, cursor, schema, None, None, None, state)
        else:
            remove_grants(module, msg, cursor, schema, system_grants, object_privs, directory_privs, state)

    elif (state == 'absent' or state == 'REMOVEALL') and role:
        check_role_exists(module, msg, cursor, role)
        remove_grants(module, msg, cursor, role, system_grants, object_privs, directory_privs, state)
        #module.exit_json(msg=msg, changed=True)
        #else:
        #module.exit_json(msg='The role (%s) doesn\'t exist' % role, changed=False)

    else:
        module.fail_json(msg='Missing schema or role', changed=False)

    module.fail_json(msg='Unknown object - should never be reached', changed=False)


from ansible.module_utils.basic import *
from oracle_utils import oracle_connect
from collections import namedtuple

if __name__ == '__main__':
    main()
